go
> 怎么运行一个该语言程序
************************************************************
test.go
go build test.go    # 编译，生成二进制文件
go run test.go      # 编译并马上执行
------------------------------------------------------------
// 如果是执行文件就必须要是main
package main

// 导包
import "fmt"
// 入口
func main() {
	// 调用
	fmt.Println("hello world")
}
------------------------------------------------------------
************************************************************

> 了解该语言的
	>> 基本数据类型
		 >>> 布尔
		 		 >>>> true
				 >>>> false
		 >>> 数字
		 		 >>>> int
				 >>>> float32
				 >>>> float64
		 >>> 字符串
		 		 >>>> string 字面量只能通过双引号定义
		 >>> 派生
		 		 >>>> 指针类型（Pointer）
				 			>>>>> 指针使用流程：
										定义指针变量。
										为指针变量赋值。
										访问指针变量中指向地址的值。
							>>>>> 空指针
										指针定义后没有分配任何变量，它的值为nil，即空指针，指代零值或空值
************************************************************
指针变量指向了一个值的内存地址，使用指针前需要声明指针。
------------------------------------------------------------
package main

import "fmt"

func main() {
   var a int= 20   /* 声明实际变量 */
   var ip *int        /* 声明指针变量 */
   ip = &a  /* 指针变量的存储地址 */
   fmt.Printf("a 变量的地址是: %x\n", &a  )
   /* 指针变量的存储地址 */
   fmt.Printf("ip 变量储存的指针地址: %x\n", ip )
   /* 使用指针访问值 */
   fmt.Printf("*ip 变量的值: %d\n", *ip )
}
------------------------------------------------------------
************************************************************
										
				 >>>> 数组类型
************************************************************
数组具有相同唯一类型的一组已编号且长度固定的数据项序列
数组元素可以通过索引（位置）来读取（修改），0开始
------------------------------------------------------------
/*
# var balance [10] float32   声明数组
# balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 初始化数组
# 不定长数组 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度
# balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
# 如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小
# 访问数组元素
var salary float32 = balance[9]
*/
package main

import "fmt"

func main() {
   var i,j,k int
   // 声明数组的同时快速初始化数组
   balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}

   /* 输出数组元素 */         ...
   for i = 0; i < 5; i++ {
      fmt.Printf("balance[%d] = %f\n", i, balance[i] )
   }
   
   balance2 := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}
   /* 输出每个数组元素的值 */
   for j = 0; j < 5; j++ {
      fmt.Printf("balance2[%d] = %f\n", j, balance2[j] )
   }

   //  将索引为 1 和 3 的元素初始化, 未定义初始化为0值
   balance3 := [5]float32{1:2.0,3:7.0}  
   for k = 0; k < 5; k++ {
      fmt.Printf("balance3[%d] = %f\n", k, balance3[k] )
   }
}
------------------------------------------------------------
************************************************************
				 >>>> 结构化类型（struct）
************************************************************
------------------------------------------------------------
/*
声明
type Books struct {
   title string
   author string
   subject string
   book_id int
}
创建
Books{"GO",  "me", "GO", 100}
或 Books{title: "Go", author: "me", subject: "Go", book_id: 100}
或缺省 Books{title: "Go", author: "me"} 缺省值为0或空
访问
var book Books
book.title
*/
package main

import "fmt"

type Books struct {
   title string
   author string
   subject string
   book_id int
}

func main() {
   var Book1 Books        /* 声明 Book1 为 Books 类型 */
   var Book2 Books        /* 声明 Book2 为 Books 类型 */

   /* book 1 描述 */
   Book1.title = "Go 语言"
   Book1.author = "www.runoob.com"
   Book1.subject = "Go 语言教程"
   Book1.book_id = 6495407

   /* book 2 描述 */
   Book2.title = "Python 教程"
   Book2.author = "www.runoob.com"
   Book2.subject = "Python 语言教程"
   Book2.book_id = 6495700

   /* 打印 Book1 信息 */
   printBook(Book1)

   /* 打印 Book2 信息 */
   printBook(Book2)
}

func printBook( book Books ) {
   fmt.Printf( "Book title : %s\n", book.title)
   fmt.Printf( "Book author : %s\n", book.author)
   fmt.Printf( "Book subject : %s\n", book.subject)
   fmt.Printf( "Book book_id : %d\n", book.book_id)
}
------------------------------------------------------------
************************************************************
				 >>>> channel类型
				 			https://www.runoob.com/w3cnote/go-channel-intro.html
				 >>>> 函数类型
				 			>>>>> 普通函数
************************************************************
------------------------------------------------------------
/*
func 函数名(形式参数列表)(返回值列表){
    函数体
}
*/
------------------------------------------------------------
************************************************************
							>>>>> 参数
************************************************************
------------------------------------------------------------
如果同一组参数是相同类型可以不必都写出来 x y
func hypot(x, y float64) float64 {
    return math.Sqrt(x*x + y*y)
}
fmt.Println(hypot(3,4)) // "5"
空白标识符 _ 可以强调某个参数为被使用
func first(x int, _ int) int { return x }
------------------------------------------------------------
************************************************************
							>>>>> 返回值
************************************************************
------------------------------------------------------------
如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值
如果一个函数在声明时，包含返回值列表，那么该函数必须以 return 语句结尾
可以多返回值
func typedTwoValues() (int, int) {
    return 1, 2
}
接收
a, b := typedTwoValues()
带有变量名的返回值, 函数声明时将返回值命名为 a 和 b，因此可以在函数体中直接对函数返回值进行赋值，在命名的返回值方式的函数体中，在函数结束前需要显式地使用 return 语句进行返回（就是对返回值起到标记的作用，为了代码可读性不应该经常使用）
func namedRetValues() (a, b int) {
    a = 1
    b = 2
    return
}
同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误
------------------------------------------------------------
************************************************************
							>>>>> 匿名函数
************************************************************
------------------------------------------------------------
/*
定义并调用
func(data int) {
    fmt.Println("hello", data)
}(100)

匿名函数赋值调用
f := func(data int) {
    fmt.Println("hello", data)
}
f(100)
*/
------------------------------------------------------------
************************************************************
				 
				 >>>> 数组类型
				 			>>>>> 切片是对数组的抽象

************************************************************
定义
------------------------------------------------------------
// 声明一个未指定大小的数组定义切片
var a []int
// 或使用make创建，len是切片初始长度，capacity是容量可选参数。从实践意义上，切片长度是当前切片可直接访问的元素的数量，而切片容量则是当前切片扩展后能访问的元素个数。slice只是基于数组的一种抽象类型，它自身并没有保存什么数据，其底层只是指向了一个数组而已。capacity不用在意，在动态添加元素时，会自动发生改变。
slice1 := make([]int, len, capacity)
------------------------------------------------------------
初始化
------------------------------------------------------------
// 直接初始化, len=cap=3
s := []int {1, 2, 3}
// s是数组arr的引用
s := arr[:]
// 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片
s := arr[startIndex:endIndex]
------------------------------------------------------------
len(), cap()
------------------------------------------------------------
// 切片是可索引的，并且可以由 len() 方法获取长度
// 切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少
package main
import "fmt"
func main() {
   var numbers = make([]int,3,5)
   printSlice(numbers)
}
func printSlice(x []int){
   fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
------------------------------------------------------------
append(), copy()
------------------------------------------------------------
/* 向切片添加一个元素，append并未改变切片本身，而是返回了一个新的切片对象 */
numbers = append(numbers, 1)
printSlice(numbers)
/* 同时添加多个元素 */
numbers = append(numbers, 2,3,4)
printSlice(numbers)
/* 创建切片 numbers1 是之前切片的两倍容量*/
numbers1 := make([]int, len(numbers), (cap(numbers))*2)
/* 拷贝 numbers 的内容到 numbers1 */
copy(numbers1,numbers)
printSlice(numbers1)  
------------------------------------------------------------
************************************************************
				 >>>> 接口类型（interface）
************************************************************
接口名在单词后面一般都需添加er的后缀，代表这是一个接口
当接口名与方法名都是大写时，代表该接口与方法均可被外部包进行访问
参数列表以及返回值列表参数变量名可以省略
------------------------------------------------------------
package main
import "fmt"
type Book struct {
	bookName string
}
func newBook(name string) *Book {
	return &Book{name}
}
func (p *Book) getName() string {
	return p.bookName
}
func (p *Book) setName(name string) {
	p.bookName = name
}
// 定义的接口，只需实现定义的接口即可
type BookInterface interface {
	getName() string
	setName(name string)
}
func main() {
	var book = newBook("matrix")
	var bi BookInterface = book
	bi.setName("aaa")
	fmt.Println(bi.getName())
}
------------------------------------------------------------
************************************************************
			   >>>> Map 类型
				 			>>>>> Map是一种无序的键值对的集合。Map使用hash表实现
************************************************************
声明
------------------------------------------------------------
// 普通声明一个map, key-value 类型为string-string
var m map[string]string
// 使用make初始化，一定要初始化才可以操作
m := make(map[string]string)
------------------------------------------------------------
使用
------------------------------------------------------------
package main
import "fmt"
func main() {
	var m map[string]string
	m = make(map[string]string)
	// 插入键值对
	m["a"] = "a"
	// 取值
	val := m["a"]
	fmt.Println(val)
	// 遍历map
	for i := range m {
		fmt.Printf("%s: %s\n", i, m[i])
	}	
}
------------------------------------------------------------
************************************************************
	>> 基本语法和流程控制,判断/分支/循环等
	>> 主要数学运算符
	>> print函数的使用
	
基本数据类型
>

> 前后端分离，什么是跨域
> RedLock算法
> 二轮linux命令 二维数组找target
> 三面SQL

Python基础：
1、Python基本数据结构有哪些
2、Python数据类型间的互转，举例子
3、数组的遍历和切片
4、有序字典
5、迭代器，优缺点
6、__init__和__new__的区别
7、面向对象的特性、Python中如何体现面向对象
8、pass语句
9、Python2和Python3的区别，编码上的区别
10、Python可变和不可变数据类型
11、lambda匿名函数
12、思路题：数据的去重和排列组合方法，内置类库
13、正则匹配需要哪几个关键步骤
14、场景：如何匹配邮箱和手机号码
15、场景：匹配pattern为多种数据类型组合的情况
16、异常处理try except finally 介绍
17、数组深浅拷贝
18、python内置库
19、在python中直接执行命令行语句有什么方法
20、python2编码重置编码使用哪个库
21、python传参*args和**kwargs，传值和传引用的区别
22、with open 和open打开文件区别，怎么选择
23、Python中在字典中如何按键和值排序
24、[1,2,3]+[4,5,6]结果
25、Python运行效率较低，如何提效。并行：多线程和协程、多进程和进程池；语句上调优：在for前加条件判断
MySQL:
26、事务的特性
27、索引的数据结构，如何挑选比较合理
28、查询优化的场景
Linux:
29、文件管理、磁盘管理、系统管理中的常用命令
30、查看内存、网络端口、磁盘容量的命令
31、log日志做分组统计或关键数据的筛选可以使用哪些命令;grep、awk(大量文本数据处理比较快的方式)
网络：
32、TCP和UDP
33、两者的使用场景
算法题：（如流在线编程）
34、最长不含重复字符的子字符串
请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

链表去环
指针a一次两格，指针b一次一格，如果有环，最后一定a会追上b，即a、b指向同一节点。

例如链表A->B->C->D->B->C->D，两个指针最初都指向节点A，进入第一轮循环，指针1移动到了节
点B，指针2移动到了C。第二轮循环，指针1移动到了节点C，指针2移动到了节点B。第三轮循环，
指针1移动到了节点D，指针2移动到了节点D，此时两指针指向同一节点，判断出链表有环。

redis面试
手写快排
http过程


