> TODO
	新老 gateway VS 的对比

> GW 里面 没有 listener 概念，只有到后面产生 Proxy 时才有
  >> httpGW
		VS ref
	>> TcpGW
> proxy 可以对应为 node，envoy 由 NodeID的标记，node属于 nodeGroup ，所有表示多个listener 的GW，需要指定一个ng_name，作为被分配到哪个

> 新GW 更接近之前的 Proxy 对象，是listener 的集合，listener 由一系列 server 组成。
	>> 旧概念
		
	>> proxy -> GW
	>> GW    -> GWListener
	

> 新 gateway proto fields
	>> ssl bool

    option (core.solo.io.resource).short_name = "gw";
    option (core.solo.io.resource).plural_name = "gateways";

    // if set to false, only use virtual services without ssl configured.
    // if set to true, only use virtual services with ssl configured.
**    bool ssl = 1;

    // the bind address the gateway should serve traffic on
**    string bind_address = 3;

    // bind ports must not conflict across gateways for a single proxy
**    uint32 bind_port = 4;

    // top level optional configuration for all routes on the gateway
**    gloo.solo.io.ListenerOptions options = 5;

    // Status indicates the validation status of this resource.
    // Status is read-only by clients, and set by gloo during validation
    core.solo.io.Status status = 6 [(extproto.skip_hashing) = true];

    // Metadata contains the object metadata for this resource
    core.solo.io.Metadata metadata = 7;

    // Enable ProxyProtocol support for this listener
**    google.protobuf.BoolValue use_proxy_proto = 8;

    // The type of gateway being created
    // HttpGateway creates a listener with an http_connection_manager
    // TcpGateway creates a listener with a tcp proxy filter
**    oneof GatewayType {
        HttpGateway http_gateway = 9;
        TcpGateway tcp_gateway = 10;
    }
    repeated string proxy_names = 12;
}


message HttpGateway {
    // Names & namespace refs of the virtual services which contain the actual routes for the gateway.
    // If the list is empty, all virtual services in all namespaces that Gloo watches will apply,
    // with accordance to `ssl` flag on `Gateway` above.
    // The default namespace matching behavior can be overridden via `virtual_service_namespaces` flag below.
    // Only one of `virtualServices` or `virtualServiceSelector` should be provided.
    repeated core.solo.io.ResourceRef virtual_services = 1;

    // Select virtual services by their label. If `virtual_service_namespaces` is provided below, this will apply only
    // to virtual services in the namespaces specified.
    // Only one of `virtualServices` or `virtualServiceSelector` should be provided.
    map<string, string> virtual_service_selector = 2;

    // The virtual services that compose a gateway are referenced by name via `virtual_services` or by label selector
    // via `virtual_service_selector` on the `HttpGateway` object.
    // By default, virtual services match if they are in any namespace watched by Gloo.

    // Restrict the search by providing a list of valid search namespaces here.
    // Setting '*' will search all namespaces, equivalent to omitting this value.
    repeated string virtual_service_namespaces = 3;

    // HTTP Gateway configuration
    gloo.solo.io.HttpListenerOptions options = 8;
}

message TcpGateway {
    // TCP hosts that the gateway can route to
    repeated gloo.solo.io.TcpHost tcp_hosts = 1;
    // TCP Gateway configuration
    gloo.solo.io.TcpListenerOptions options = 8;
}








message Gateway {
    option (core.solo.io.resource).short_name = "gw";
    option (core.solo.io.resource).plural_name = "gateways";	
    // Status indicates the validation status of this resource.
    // Status is read-only by clients, and set by gloo during validation
    core.solo.io.Status status = 1 [(extproto.skip_hashing) = true];
    // Metadata contains the object metadata for this resource
    core.solo.io.Metadata metadata = 3;
		// 多个listeners 组成一个逻辑上的GW
**    repeated GwListener listeners = 4;
	//本gateway所在的proxy
		// 多个nodeGroup 也可以组成一个逻辑上的网关
**    repeated string ng_names = 5;
}

//TCP Server当前版本不支
message GwTcpServer {
}

message GwHttpServer {
    gloo.solo.io.HttpServerOptions options = 1;
    repeated core.solo.io.ResourceRef virtual_services = 2;
}

message GwServer {
        gloo.solo.io.TlsServer ssl_configurations =1;
	//google.protobuf.BoolValue use_proxy_proto = 2;
	oneof server_type {
        //
             GwHttpServer  http_server= 3;
             GwTcpServer tcp_listener = 4;
    }
}


message GwListener {
	//绑定的地址只能是float IP，该IP地址存放在NG里，这里如何获取得到 
**	string bind_address = 2;
**    uint32 bind_port = 3;
  	repeated GwServer  srvs=4;
	//listener选项
    gloo.solo.io.ListenerOptions options = 8;
    // Metadata for the individual listener
    // This data is opaque to Gloo, used
    // by controllers to track ownership of listeners within a proxy
    // as they are typically generated by a controller (such as the gateway)	
    google.protobuf.Struct metadata = 9 [(extproto.skip_hashing) = true];

}



> webhook 的服务方案
> apiserver etcd 每一种资源都会建立一个连接，apiserver 注释掉 不需要的 controller 的注册
> 用户管理 使用 自己的验证服务器
> k8s 1.22 高版本 去掉原生的 模块 client-go 版本 证书
> 声明式Api ，优势是解耦，劣势是异常处理比较麻烦
> 版本号加上，作为版本兼容机制
> controller 中需要把状态写到 status
> 这个状态可以给前端用
> 自己封装一层生命周期的管理，
> 在 controller 处理时，业务处理失败直接 返回异常即可，会将这个请求重新放入通知队列，controller 进行下一次处理
> controller 并发时，直接update，因为 etcd 的 mvcc 机制，其他协程会处理失败，因为它们是老版本的。
> webhook 只有一个，controller 会分开多个
> 普通的参数校验由 jsonschema 实现， webhook 实现jsonschema 实现不了的
> 写到etcd 的数据使用 英文
> dryrun 作为测试
> 当controller 想获取到其他 crd ，需要访问 restful 接口或直接使用 client-go watch

> k8s yaml 文件 schema 在什么时候开始校验的


> 问题总结
  >> 应该使用k8s 1.22 高版本部署，同时client-go 应该与 k8s 版本保持一致
  >> 写到 etcd 中的数据，不要使用中文。k8s 对中文的支持不友好                  ng_name 必须要中文
  >> apiserver 二次开发；解决当 k8s 原生controller 注册后，etcd 会与这些controller 保持一个连接，消耗系统资源，而这些恰好是我们不需要的
  >> webhook
    webhook 注册
    webhook 准入服务
    webhook 只进行 复杂的校验，jsonschema 能做的事，用schema处理
    webhook 只注册一个, controller 同一类型业务也整合为一个
  >> controller
    controller 最好使用 status 字段，作为状态的显示，方便调试
    controller 进行一层封装，在框架不支持的情况下，也能进行方便的对资源进行管理（增删改）
    controller 业务处理失败时直接返回异常，这个请求会自动回到队列，进行新一轮的处理
    controller 使用 update 可以优雅地处理并发
    controller 可以监视多个crd来进行复杂业务的处理，这样可以节省资源的消耗



> VS
************************************************************
virtualservice.proto
------------------------------------------------------------
message VirtualService {
    option (core.solo.io.resource).short_name = "vs";
    option (core.solo.io.resource).plural_name = "virtual_services";

 
    repeated string domains = 1;

    // The list of HTTP routes define routing actions to be taken for incoming HTTP requests whose host header matches
    // this virtual host. If the request matches more than one route in the list, the first route matched will be selected.
    // If the list of routes is empty, the virtual host will be ignored by Gloo.
    repeated Route routes = 2;

    // Virtual host options contain additional configuration to be applied to all traffic served by the Virtual Host.
    // Some configuration here can be overridden by Route Options.
    gloo.solo.io.VirtualHostOptions options = 3;
**    map<string, string> typed_per_filter_config =4;
    // Display only, optional descriptive name.
    // Unlike metadata.name, DisplayName can be any string
    // and can be changed after creating the resource.
    string display_name = 5 [(extproto.skip_hashing) = true];
    // Status indicates the validation status of this resource.
    // Status is read-only by clients, and set by gloo during validation
    core.solo.io.Status status = 6 [(extproto.skip_hashing) = true];	
    // Metadata contains the object metadata for this resource
    core.solo.io.Metadata metadata = 7;
}

message Route {
    // Matchers contain parameters for matching requests (i.e., based on HTTP path, headers, etc.).
    // If empty, the route will match all requests (i.e, a single "/" path prefix matcher).
    // For delegated routes, any parent matcher must have a `prefix` path matcher.
    repeated matchers.core.gloo.solo.io.Matcher matchers = 1;
    // The Route Action Defines what action the proxy should take when a request matches the route.
    oneof action {
        // This action is the primary action to be selected for most routes. The RouteAction tells the proxy to
        // route requests to an upstream.
        gloo.solo.io.RouteAction route_action = 2;

        // Redirect actions tell the proxy to return a redirect response to the downstream client.
        gloo.solo.io.RedirectAction redirect_action = 3;

        // Return an arbitrary HTTP response directly, without proxying.
        gloo.solo.io.DirectResponseAction direct_response_action = 4;

    }
	string uuid = 5;
    // The name provides a convenience for users to be able to refer to a route by name.
    string name = 6;
    headers.options.gloo.solo.io.HeaderManipulation header_manipulation  = 7;
}

------------------------------------------------------------
************************************************************

> VS_OLD
************************************************************
virtual_service.proto
------------------------------------------------------------
message VirtualService {

    option (core.solo.io.resource).short_name = "vs";
    option (core.solo.io.resource).plural_name = "virtual_services";

    // The VirtualHost contains the
    // The list of HTTP routes define routing actions to be taken
    // for incoming HTTP requests whose host header matches
    // this virtual host. If the request matches more than one route in the list, the first route matched will be selected.
    // If the list of routes is empty, the virtual host will be ignored by Gloo.
    VirtualHost virtual_host = 1;

    // If provided, the Gateway will serve TLS/SSL traffic for this set of routes
    gloo.solo.io.SslConfig ssl_config = 2;

    // Display only, optional descriptive name.
    // Unlike metadata.name, DisplayName can be any string
    // and can be changed after creating the resource.
    string display_name = 3 [(extproto.skip_hashing) = true];

    // Status indicates the validation status of this resource.
    // Status is read-only by clients, and set by gloo during validation
    core.solo.io.Status status = 6 [(extproto.skip_hashing) = true];

    // Metadata contains the object metadata for this resource
    core.solo.io.Metadata metadata = 7;
}

------------------------------------------------------------
************************************************************

		新人文档
		项目文档
		部署文档
		技术设计文档
		测试设计文档

> solo-kit 环境
	119 /opt/gocode/src/github.com/solo-io/mysk3



k config set-cluster mycluster \
	--certificate-authority=/opt/k8s/work/ca.pem \
	--embed-certs=true \
	--server=https://192.192.100.59:6443 \
	--kubeconfig=config

k config set-credentials mycluster-admin \
	--client-certificate=/opt/k8s/work/server.pem \
	--client-key=/opt/k8s/work/server-key.pem \
	--embed-certs=true \
	--kubeconfig=config

k config set-context mycluster-context \
	--cluster=mycluster \
	--user=mycluster-admin \
	--kubeconfig=config


k config set-credentials admin \
	--client-certificate=/opt/k8s/work/admin.pem \
	--client-key=/opt/k8s/work/admin-key.pem \
	--embed-certs=true \
	--kubeconfig=config

k config set-context admin-context \
	--cluster=mycluster \
	--user=admin \
	--kubeconfig=config


---
k config set-cluster kubernetes \
	--certificate-authority=/opt/k8s/work/ca.pem \
	--embed-certs=true \
	--server=https://192.192.100.59:6443 \
	--kubeconfig=config

k config set-credentials cluster-admin \
	--client-certificate=/opt/k8s/work/admin.pem \
	--client-key=/opt/k8s/work/admin-key.pem \
	--embed-certs=true \
	--kubeconfig=config

k config set-context default \
	--cluster=kubernetes \
	--user=cluster-admin \
	--kubeconfig=config

> kube-apiserver v1.23.4部署
	>> 源码包和二进制包下载
------------------------------------------------------------
wget https://storage.googleapis.com/kubernetes-release/release/v1.23.4/kubernetes-server-linux-amd64.tar.gz
tar zxvf kubernetes-server-linux-amd64.tar.gz
# server 里面有 二进制包
ls kubernetes/server
ln -s ${PWD}/kubernetes/server/bin/kube-apiserver /usr/local/bin/
------------------------------------------------------------
	>> systemd 进行管理
************************************************************
kube-apiserver.conf
------------------------------------------------------------
KUBE_APISERVER_OPTS="--logtostderr=false \
--v=5 \
--etcd-servers=http://127.0.0.1:2379 \
--bind-address=192.192.100.59 \
--secure-port=6443 \
--advertise-address=192.192.100.59 \
--allow-privileged=true \
--service-cluster-ip-range=192.192.100.1/24 \
--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,NodeRestriction \
--authorization-mode=RBAC,Node \
--enable-bootstrap-token-auth=true \
--token-auth-file=/opt/k8s/work/token.csv \
--service-node-port-range=30000-32767 \
--kubelet-client-certificate=/opt/k8s/work/server.pem \
--kubelet-client-key=/opt/k8s/work/server-key.pem \
--tls-cert-file=/opt/k8s/work/server.pem  \
--tls-private-key-file=/opt/k8s/work/server-key.pem \
--client-ca-file=/opt/k8s/work/ca.pem \
--service-account-key-file=/opt/k8s/work/ca-key.pem \
--service-account-issuer=api \
--service-account-signing-key-file=/opt/k8s/work/server-key.pem \
--requestheader-client-ca-file=/opt/k8s/work/ca.pem \
--proxy-client-cert-file=/opt/k8s/work/server.pem \
--proxy-client-key-file=/opt/k8s/work/server-key.pem \
--requestheader-allowed-names=kubernetes \
--requestheader-extra-headers-prefix=X-Remote-Extra- \
--requestheader-group-headers=X-Remote-Group \
--requestheader-username-headers=X-Remote-User \
--enable-aggregator-routing=true \
--audit-log-maxage=30 \
--audit-log-maxbackup=3 \
--audit-log-maxsize=100 \
--audit-log-path=/opt/k8s/logs/k8s-audit.log"
------------------------------------------------------------

/usr/lib/systemd/system/kube-apiserver.service
------------------------------------------------------------
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes

[Service]
EnvironmentFile=/opt/k8s/work/kube-apiserver.conf
# ExecStart=/opt/k8s/bin/kube-apiserver $KUBE_APISERVER_OPTS
ExecStart=/opt/k8s/kubernetes/server/bin/kube-apiserver $KUBE_APISERVER_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target
------------------------------------------------------------
************************************************************

> kubectl admin用户签发证书和生成kubeconfig
	>> cfssl 签发命令 和 生成 kubeconfig 文件
------------------------------------------------------------
# 签发 ca
cfssl gencert -initca ca-csr.json | cfssljson -bare ca -
# 签发 admin 用户证书，这个与用户角色绑定了
cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server
# 生成 kubeconfig ，会生成在本目录，需要把 kubeconfig 移到 $HOME/.kube/下，不然会报错 Unable to connect to the server: x509: certificate signed by unknown authority
k config set-cluster kubernetes \
	--certificate-authority=/opt/k8s/work/ca.pem \
	--embed-certs=true \
	--server=https://192.192.100.59:6443 \
	--kubeconfig=config

k config set-credentials cluster-admin \
	--client-certificate=/opt/k8s/work/admin.pem \
	--client-key=/opt/k8s/work/admin-key.pem \
	--embed-certs=true \
	--kubeconfig=config

k config set-context default \
	--cluster=kubernetes \
	--user=cluster-admin \
	--kubeconfig=config

k config use-context default --kubeconfig=config
# config 文件转移到 kube 目录下
mv ./config $HOME/.kube/
# 检验
k get ns
------------------------------------------------------------
	>> json文件实例
************************************************************
ca-config.json
# 这个profiles kubernetes 需要这样设置，不然后面签发证书报错 5100
------------------------------------------------------------
{
  "signing": {
    "default": {
      "expiry": "87600h"
    },
    "profiles": {
      "kubernetes": {
         "expiry": "87600h",
         "usages": [
            "signing",
            "key encipherment",
            "server auth",
            "client auth"
        ]
      }
    }
  }
}
------------------------------------------------------------

ca-csr.json
# 除了 hosts 字段外建议全抄，与 k8s 角色绑定有关
------------------------------------------------------------
{
  "CN": "kubernetes",
  "hosts": [
    "127.0.0.1",
    "192.192.100.59",
    "192.192.100.60",
    "192.192.100.61",
    "kubernetes",
    "kubernetes.default",
    "kubernetes.default.svc",
    "kubernetes.default.svc.cluster",
    "kubernetes.default.svc.cluster.local."
  ],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Shanghai",
      "L": "Shanghai",
      "O": "k8s",
      "OU": "System"
    }
  ]
}
------------------------------------------------------------

admin-csr.json
# 为admin用户签发证书，除 hosts 外建议全抄
------------------------------------------------------------
{
  "CN": "admin",
  "hosts": [
    "127.0.0.1",
    "192.192.100.59",
    "192.192.100.60",
    "192.192.100.61",
    "kubernetes",
    "kubernetes.default",
    "kubernetes.default.svc",
    "kubernetes.default.svc.cluster",
    "kubernetes.default.svc.cluster.local."
  ],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "O": "system:masters",
      "OU": "System",
      "L": "Shanghai",
      "ST": "Shanghai"
    }
  ]
}
------------------------------------------------------------
************************************************************

# TODOLIST
	kube-apiserver 二次开发
	