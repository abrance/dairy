TODO
> TCP/IP HTTP网络协议
> Python, shell
> Mysql, PostgreSQL, Redis
> 超融合架构, ceph, 虚拟化
> pandas, numpy
> nginx

> 算法
> 遇到的问题


TCP/IP协议
> https://blog.csdn.net/doraemon___/article/details/52711221
> 重点
	>> TCP/IP参考模型
		>>> TCP/IP参考模型与层次结构
		
OSI模型            TCP/IP模型
+------+          +----------+
|应用层+-+        |          |
+------+ |        |          |
|表示层+--------> | 应用层   |   数据段
+------+ |        |          |
|会话层+-+        |          |
+------+          +----------+
|传输层+--------> | 传输层   |   数据包
+------+          +----------+
|网络层+--------> |网络互连层|   数据帧
+------+          +----------+
|链路层+-+        |          |
+---------------> |主机网络层|    比特
|物理层+-+        |          |
+------+          +----------+

 +------+ +-----+ +-----+       +-----+
 |Telnet| | FTP | |Voice|  ...  |     |  Application Level
 +------+ +-----+ +-----+       +-----+
			 |   |         |             |
			+-----+     +-----+       +-----+
			| TCP |     | RTP |  ...  |     |  Host Level
			+-----+     +-----+       +-----+
				 |           |             |
			+-------------------------------+
			|    Internet Protocol & ICMP   |  Gateway Level
			+-------------------------------+
										 |
				+---------------------------+
				|   Local Network Protocol  |    Network Level
				+---------------------------+

									 Protocol Relationships

												 Figure 2.

		>>> TCP/IP 报文格式
				>>>> IP 头
				>>>> https://www.rfc-editor.org/rfc/inline-errata/rfc791.html

                             RFC791
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Example Internet Datagram Header

                               Figure 4.

				版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。　　
				报头长度（InternetHeader Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。　　
		　　服务类型（Typeof Service，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。实际上，大部分主机会忽略这个字段，但一些动态路由协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。　　
		　　总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。　　
		　　标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。　　
		　　标志位字段：占3比特。标志一份数据报是否要求分段。　　
		　　段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。　　
		　　生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。　　
		　　协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。　　
		　　头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。　　
		　　源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。　　
		　　可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求.
				>>>> TCP 头
				>>>> https://www.rfc-editor.org/rfc/rfc793.html
                              RFC793
                         TCP Header Format

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            TCP Header Format

          Note that one tick mark represents one bit position.

                               Figure 3.


		　　源、目标端口号字段：占16比特。TCP协议通过使用"端口"来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在"众所周知的端口"（Well-KnowPort）为用户提供服务。
		　　顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。　　
		　　确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。　　
		　　头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。　　
		　　标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：　　
				　　URG：紧急指针（urgent pointer）有效。　　
				　　ACK：确认序号有效。　　
				　　PSH：接收方应该尽快将这个报文段交给应用层。　　
				　　RST：重建连接。　　
				　　SYN：发起一个连接。　　
				　　FIN：释放一个连接。　　
		　　窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。　　
		　　TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。　　
		　　紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。　　
		　　选项字段：占32比特。可能包括"窗口扩大因子"、"时间戳"等选项。
		    >>>> UDP 头
				>>>> https://www.rfc-editor.org/rfc/rfc768.html
				
				        RFC768
	 0      7 8     15 16    23 24    31
	+--------+--------+--------+--------+
	|     Source      |   Destination   |
	|      Port       |      Port       |
	+--------+--------+--------+--------+
	|                 |                 |
	|     Length      |    Checksum     |
	+--------+--------+--------+--------+
	|
	|          data octets ...
	+---------------- ...

			 User Datagram Header Format


	      源、目标端口号字段：占16比特。作用与TCP数据段中的端口号字段相同，用来标识源端和目标端的应用进程。　　
	 　　长度字段：占16比特。标明UDP头部和UDP数据的总长度字节。　　
	 　　校验和字段：占16比特。用来对UDP头部和UDP数据进行校验。和TCP不同的是，对UDP来说，此字段是可选项，而TCP数据段中的校验和字段是必须有的。
				
		>>> socket
				每个TCP UDP 数据段中都包含源端口和目标端口字段。优势把IP和一个端口号合称为一个socket，一个socket pair可以唯一确定网络中TCP连接的双方IP，源、目的端口号。
				FTP、TELNET、SMTP协议基于可靠的TCP协议。TFTP、SNMP、RIP基于不可靠的UDP协议。　　
　　   有些应用层协议占用两个不同的端口号，如FTP的20、21端口，SNMP的161、162端口。这些应用层协议在不同的端口提供不同的功能。如FTP的21端口用来侦听用户的连接请求，而20端口用来传送用户的文件数据。再如，SNMP的161端口用于SNMP管理进程获取SNMP代理的数据，而162端口用于SNMP代理主动向SNMP管理进程发送数据。　　
   　　还有一些协议使用了传输层的不同协议提供的服务。如DNS协议同时使用了TCP 53端口和UDP 53端口。DNS协议在UDP的53端口提供域名解析服务，在TCP的53端口提供DNS区域文件传输服务

		>>> TCP连接建立、释放时握手流程
				>>>> TCP会话通过三次握手初始化。目标是使数据段的发送和接收同步。会向对方表明一次可接收的数据量(窗口大小)，并建立逻辑连接。
						第一次握手：客户端首先将标志位SYN置为1，然后随机产生一个值seq=X的包，并将该数据包发送给server端，Client进入SYN_SENT状态，等待server确认
						第二次握手：server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack numbern=X+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
						第三次握手：Client收到确认后，检查ack number是否为X+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
			  >>>> 四次挥手
						 由于 TCP 连接是可以双向通信的（全双工），因此每个方向都必须单独进行连接和关闭
						 1 客户端发送带有 fin 标识的报文给服务端，请求通信关闭
						 2 服务端收到信息后，回复 ACK 答应关闭客户端通信(连接)请求
						 3 服务端发送带有 fin 标识的报文给客户端，也请求关闭通信
						 4 客户端回应 ack 给服务端，答应关闭服务端的通信(连接)请求

	>> IP地址

  >> ARP 协议

  >> ICMP协议

  >> IP分片

	>> 单播广播与组播

	>> IGMP

	>> TCP半关闭


TCP timewait 状态说明
> 客户端最后一次发送 ACK包后进入 TIME_WAIT 状态，而不是直接进入 CLOSED 状态关闭连接，为什么？
	>> TCP 是面向连接的传输方式，必须保证数据能够正确到达目标机器，网络不稳定时，可能丢包，所以A每次向B发送数据包后，都要求B确认，回传ACK包，A才能知道数据传送成功。如果B没有回传ACK包，A会重新发送，直到B回传ACK包。客户端最后一次向服务器回传ACK包时，有可能会因为网络问题导致服务器收不到，服务器会再次发送 FIN 包，如果这时客户端完全关闭了连接，那么服务器无论如何也收不到ACK包了，所以客户端需要等待片刻、确认对方收到ACK包后才能进入CLOSED状态。那么，要等待多久呢？数据包在网络中是有生存时间的，超过这个时间还未到达目标主机就会被丢弃，并通知源主机。这称为报文最大生存时间（MSL，Maximum Segment Lifetime）。TIME_WAIT 要等待 2MSL 才会进入 CLOSED 状态。ACK 包到达服务器需要 MSL 时间，服务器重传 FIN 包也需要 MSL 时间，2MSL 是数据包往返的最大时间，如果 2MSL 后还未收到服务器重传的 FIN 包，就说明服务器已经收到了 ACK 包。
 
> 断开连接shutdown
	>> 调用 close()/closesocket() 用于关闭socket；完全断开，会将socket 句柄从内存清除。shutdown只是关闭连接，下一次连接时还会有缓存。shutdown和close都会向对方发送FIN包，FIN 包表示数据传输完毕。



遇到的问题
> 在虚拟化中的mysql集群，为了实现连接服务不中断，当master挂掉后，vip 被slave获取，变成master。问题：当vip被slave获取后，客户端连接服务失败了。
	>> 解决： ARP协议负责ip-mac地址映射，其实是因为ARP的机制，vip被slave机器获取，但是并没有去刷新缓存。需要使用脚本对GARP对局域网发送广播，更新局域网内的ip-mac地址映射缓存，问题解决。
https://app.yinxiang.com/fx/ec055999-63e8-4b6b-9bb1-93186ef81199