> 控制结构
	>> for
************************************************************
------------------------------------------------------------
// C 一样
for init; condition; post{
}
// while一样
for condition {
}
// 死循环
for {
}
------------------------------------------------------------
************************************************************
	>> if
************************************************************
------------------------------------------------------------
// { 不能换行
if condition {
}
------------------------------------------------------------
************************************************************
	>> switch
************************************************************
------------------------------------------------------------
switch {
	case condition:
	  statement
	case condition:
	  statement
}
------------------------------------------------------------
************************************************************
	>> goto

************************************************************
------------------------------------------------------------
Here:

goto Here
------------------------------------------------------------
************************************************************

延迟执行defer

************************************************************
defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源
，典型的例子就是对一个互斥解锁，或者关闭一个文件
------------------------------------------------------------
package main
import (
    "fmt"
)
func main() {
    fmt.Println("defer begin")
    // 将defer放入延迟调用栈
    defer fmt.Println(1)
    defer fmt.Println(2)
    // 最后一个放入, 位于栈顶, 最先调用
    defer fmt.Println(3)
    fmt.Println("defer end")
}
/*
输出
defer begin
defer end
3
2
1
*/
------------------------------------------------------------
************************************************************

> 变长参数
------------------------------------------------------------
// arg ...int 接受不定数量的参数，都为int类型
func myfunc(arg ...int) {}
------------------------------------------------------------

> 回调
************************************************************
函数可作为参数传递
------------------------------------------------------------
// 函数传入，作为回调
func printit(x int, f func(int)) {
	f(x)
}
------------------------------------------------------------
************************************************************

常用函数
> fmt
	>> 格式化的IO函数，类似 printf和scanf
> io
	>> 这个包提供了原始的io操作界面。主要提供os包的封装
> bufio
	>> 实现缓冲的io，封装于io.Reader io.Writer对象，创建了Reader Writer
> sort
	>> 数组和集合的排序
> strconv
	>> strconv 包提供了将字符串，基本数据类型互转
> os
	>> 操作系统功能接口
> sync
	>> sync提供同步，如互斥锁
> flag
	>> 命令行解析
> encoding/json
	>> json
> html/template
> net/http
	>> http连接
> os/exec
	>> 执行外部命令

内存分配回收
> 分配
	>> new
		 >>> new(T) 分配了零值填充了T类型的内存空间，并返回地址（一个*T指针），指向新分配的零值
************************************************************
------------------------------------------------------------
type SyncedBuffer struct {
	lock sync.Mutex
  buffer bytes.Buffer
}
p := new(SyncedBuffer)
------------------------------------------------------------
************************************************************
	>> make
************************************************************
------------------------------------------------------------
make只能创建slice map channel 返回一个有初始值（非零）的T类型，因为这些数据结构的引用在使用前需要初始化
如slice是一个包含指向数据（array）的指针。对于他们已经初始化了内部的数据结构并填充了适当的值
// new make 不同点
var p *[]int = new([] int)            // 分配slice结构内存；很少使用
var v []int = make([]int, 100)        // v指向一个新分配的100个整数的数组
------------------------------------------------------------
************************************************************
> 回收
	>> 

> 结构字段

************************************************************
匿名字段是一个struct的时候，那么这个struct所拥有的全部字段以及方法（指绑定在这个类型上的，见最后）都被隐式地引入了当前定义的这个struct
匿名字段能够实现字段的继承, 也可间接访问
首字母大写的字段可以被导出，也就是说，在其他包中可以进行读写。字段名以小写字母开头是当前包的私有的
------------------------------------------------------------
package main
import "fmt"
type Human struct {
    name string
    age int
    weight int
}
type Student struct {
    Human  // 匿名字段，那么默认Student就包含了Human的所有字段
    speciality string
}
func main() {
    // 我们初始化一个学生
    mark := Student{Human{"Mark", 25, 120}, "Computer Science"}
    // 我们访问相应的字段
    fmt.Println("His name is ", mark.name)
    fmt.Println("His age is ", mark.age)
    fmt.Println("His weight is ", mark.weight)
    fmt.Println("His speciality is ", mark.speciality)
    // 间接访问
		fmt.Println("", mark.Human)
		fmt.Println("", mark.Human.age)		
}
------------------------------------------------------------
// 内置的类型也可作为匿名字段
------------------------------------------------------------
type Student struct {
    Human  // 匿名字段，struct
    Skills // 匿名字段，自定义的类型string slice
    int    // 内置类型作为匿名字段
    speciality string
}
------------------------------------------------------------
************************************************************

字符串处理
> +
	>> a = "1" + "2" 字符串类型在go中是不可改变的，因此每次操作实际都要新分配字符串，所以在字符串比较多的时候效率不高
> strings.Join()
************************************************************
-----------------------------------------------------------
s := []string {"1", "2"}
strings.Join(s, ",")
------------------------------------------------------------
************************************************************
> 字符串截取
************************************************************
在golang中可以通过切片截取一个数组或字符串，但是当截取的字符串是中文时，可能会出现的问题是：
由于中文一个字不只是由一个字节组成，所以直接通过切片可能会把一个中文字的编码截成两半，结果导致最后一个字符是乱码。
可以先将其转为[]rune，再截取后，转回string
------------------------------------------------------------
s := "abcdefg"
s = string([]byte(s)[1:3])
fmt.Println(s)
// 带中文等特殊字符
s := "a你好cd"
s = string([]rune(s)[:3])
fmt.Println(s)
------------------------------------------------------------
************************************************************
> 字符串替换
************************************************************
//第四个参数小于0，表示所有的都替换
------------------------------------------------------------
fmt.Println(strings.Replace("ABAACEDF", "A", "a", 2))  // aBaACEDF
fmt.Println(strings.Replace("ABAACEDF", "A", "a", -1)) // aBaaCEDF
------------------------------------------------------------
************************************************************
> 查询
************************************************************
查询是否为子串
------------------------------------------------------------
fmt.Println(strings.Contains("hello world", "lo")) //true
------------------------------------------------------------
查询个数
------------------------------------------------------------
strings.Count("hello world", "l")   // 3
------------------------------------------------------------
查询子串第一次出现位置
------------------------------------------------------------
strings.Index("hello world", "l")
strings.LastIndex("hello world", "l")   // 最后一次
------------------------------------------------------------
************************************************************
> 分隔
************************************************************
split
------------------------------------------------------------
strings.Split("hello world", "l") //[he  o wor d]
------------------------------------------------------------
str为分隔符，将s切分成多个子串，结果中不包含str本身
------------------------------------------------------------
strings.SplitN("hello world", "l", 2) //[he lo world]
strings.SplitN("hello world", "l", 4) //[he  o wor d]
------------------------------------------------------------
删除首尾包含在str的字符
------------------------------------------------------------
strings.Trim("/hello world/", "/") //hello world
------------------------------------------------------------
************************************************************

> go 函数与方法
************************************************************
函数与方法有区别：方法在func关键字后是接受者而不是函数名
------------------------------------------------------------
package main

import "fmt"

type myint int
//乘2
func (p *myint) mydouble() int {
	*p = *p * 2
	return 0
}
//平方
func (p myint) mysquare() int {
	p = p * p
	fmt.Println("mysquare p = ", p)
	return 0
}
func main() {
	var i myint = 2
	i.mydouble()
	fmt.Println("i = ", i)
	i.mysquare()
	fmt.Println("i = ", i)
}
------------------------------------------------------------
************************************************************

.(type)
************************************************************
获取接口实例实际的类型指针，以此调用实例所有可调用的方法，包括接口方法及自有方法。
需要注意的是该写法必须与switch case联合使用，case中列出实现该接口的类型
------------------------------------------------------------
package main

import "fmt"

type in interface {
	String()
}

type A struct {
}

func (a *A) String() {
	fmt.Println("I am A!")
}

func (a *A) StringA() {
	fmt.Println("I am A! Doing StringA()")
}

type B struct {
	str string
}

func (b *B) String() {
	fmt.Println("I am B!")
}

func (b *B) StringB() {
	fmt.Println("I am B! Doing StringB()")
}

func main() {

	var i in
	i = &B{}
	//t := i.(type) //编译报错:use of .(type) outside type switch 
	switch t := i.(type) {
	case *A:
		t.String()
		t.StringA()
	case *B:
		t.String()
		t.StringB()
	default:
	}
}
------------------------------------------------------------
************************************************************