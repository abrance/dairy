> 7.2

> TODO
	>> 单机部署整套脚本
	>> 可视化功能相关日志统计
	>> 使用多路复用IO 模型

	>> 面试题参考答案
	
	>> BPF 书籍 P4 目录
	>> cilium 部署文档
		>>> 环境要求 内核 Linux 4.9 以上  Kubernetes >= 1.16 CNImode
		>>> k8s 环境
		>>> 下载 helm cilium 包
		>>> 安装 cilium
		>>> 修改 deployment
			tolerations:
			  - operator: Exists
		>>> 暴露 pod 
			kubectl port-forward -n kube-system svc/hubble-ui --address 0.0.0.0 --address :: 12000:80

	>> 清楚 cilium 内部的东西

	>> 71 73 78 79

	>> xDS 服务基本原理

	>> xds 服务器的 IP 地址使用浮动 IP 地址

> 重要不紧急
	>> upstream 测试用例
	>> 三大转换单元测试用例
	>> 联调测试用例

	>> traceroute
	>> emacs M-x rm-larger 实现 选中区域每行删掉一个 > 并缩进两格	
	>> 自动生成文档脚本
		>> 默认对每个函数生成相应的层级文档
		>> exclusive 对不想要的函数进行排除 exclusiveHeader exclusiveBody   header 表示这个函数不需要解析,  body 表示函数里面这一行不需要解析,  上面有一层 scope
		>> 单行函数注解(支持 code-region 第一行按照 funcionName 注释 格式编写)
	>> 执行进程时通过管理 PID 来优雅关闭进程
		>> 执行后台进程时，保存进程pid
		nohup ./server10000 & echo $! > server10000.pid
		>> python python-daemon 包实现了 context 进行 PID 进程管理


> 未解决 bug 
	>> sub_alt

> 已解决 bug

> 读书
	>> 程序员修炼之道
	>> 深入理解 linux 内核
	>> 深入理解Linux 网络内幕
	>> Raft 协议	
	>> 大规模分布式系统

> 每日
	>> 22 编译打包
		>>> /home/envoy/projects ./deploy.sh
	>> 70 更新webserver web
		>>> /opt/   ./main.sh

 > call
	>> 家乐现在将最新的放到 develop 分支，为了使用到最新的前端，使用了 x-apigateway-web develop 分支进行打包，后面 develop 分支需要合并到 main 分支，要记得 将 22 的 x-apigateway-web 切换回 main 分支


> gitlab release 接口
	https://blog.csdn.net/a112626290/article/details/105404318

> 修改时区
	>> ntpdate 时间同步后可能还是有时区对不上问题，这时可能需要修改时区

> 并发连接数和请求数
	>> 并发连接数 可以理解为同一时间 TCP 连接的个数，而请求数可能比这个值多一些，因为这些请求可能通过这些连接来传递数据


> sidecarProxy routerProxy
	>> what
		nodeType 节点类型 
	>> sidecarProxy
		SidecarProxy type is used for sidecar proxies in the application containers
	>> routerProxy
		Router type is used for standalone proxies acting as L7/L4 routers

> client-go   条件锁


> X网关的网络解决哪些问题
	>> 用户 API  负载均衡
	>> 用户 API SSL 卸载
	>> 用户 API 

> 数据中心流量分类
	>> 东西向流量
		>>> 数据中心内部服务器之间交互的流量，也叫东西向流量或者横向流量
	>> 南北向流量
		>>> 数据中心外部用户和内部服务器之间交互的流量


> 可视化相关元素
	1、不同运营商对应的api访问质量分布（运营商名称、访问总数、失败总数）,可以根据时间段（天、周、月、不限）来进行筛选
	2、省份访问排行（前10个，省份、api名称、总数）
	3、整体api调用排行（api名称、总数），可以根据时间段（天、周、月、不限）来进行筛选
	4、默认当日所有api访问总量、当日失败总数、当日总流量
	5、按状态码统计（404,500,200，其他）,可以根据时间段（天、周、月、不限）来进行筛选
	6、按路由行为统计（直接响应、重定向、转发）,可以根据时间段（天、周、月、不限）来进行筛选
	7、api总数（所有api的数量），总流量数
	8、api实时调用情况（滚动效果）（api、请求方法、流量、省份、状态、请求时间）
	9、api调用趋势（时间、调用次数），做成曲线图的形式
	10、api的每日调用情况（假设总共100个api，当时只调用了80个，则采用刻度表的形式，展示80%）

  针对于多套X网关，直接统计总数，做成下拉切换的形式


> 可视化功能相关日志统计 TODO
	>> models
		>>> cache 数据结构
		>>> mongodb models 建立
		>>> 每个表每个用到的字段都要写到文档
	>> 部署文档


> TCP 需要解决
	>> 拆包
		当客户端在短时间内，或者是并发下，发送几条序列时[0 1 2 3] [2 8 7] [9 88],在服务端有可能接收到的是[0 1 2 3 2 8 7 9 88]，但很显然，这是3条消息，需要在服务端进行拆包，分离成三条有效的消息才可以。
	>> 心跳
		当客户端和服务端连接后，客户端因为某些原因崩溃了，没有走正常的离线操作，那么这时，服务端无法感知到客户端的结束，会继续把持着连接，耗费资源，所以需要设定心跳。由客户端每隔一段时间发送一条消息，让服务端知道他还活着。
	>> 消息分离
		所有的客户端消息，都从同一个conn中留出，而不同的消息有不同的处理方法，请求参数，需要对拆分出来的消息进行分离，适用予不同的handler。
	>> 维护成本
		维护成本体现在两点。第一，从官方的库示例可以看出，底层的写法很多问题没有考虑到，仅仅是涉及到连接的建立和对发，在开发时，不同的使用者写法群魔乱舞，很难做到统一，人数越多越难维护。第二，仅使用基本包在需求迭代时，很容易让代码变得越来越臃肿，比如临时给你一个需求，要求像http那样，支持某一个handler的中间件。


> ss 数据大图
	>> 需求
		>>> 热力值统计（红点）
			>>>> 根据省市区分别进行热力值统计，需要 省级 市级 区级 标识 （时间概念: 每天凌晨到当下） (limit 10)
			select province_id, cnt(id) from access_log where $Y$m$D<time<$NOW group_by province_id; 省级
			select city_id, cnt(id) from access_log where $Y$m$D<time<$NOW and province_id = $province_id group_by city_id; 市级
			select distinct_id, cnt(id) from access_log where $Y$m$D<time<$NOW and city_id = $city_id group_by distinct_id; 区级
			
		>>> 实时API调用（蓝点）
			>>>> 实时 api 调用情况
				select src_region_id, dst_region_id, path, time from access_log order_by time desc; 最近的一个 api 调用


> 查询每个省 成功 失败 请求数 list
	$group: {_id : { province_id: $province_id, status_code: $status_code_field_name},  ...}
	

> 技术点
	>> 统计数量 	group_by分组查询
		.aggregate([{$match: {xxx: xxxx}}, {$group: {_id: region_id, cnt: {$sum: 1}}}])
	>> 时间筛选
		{time: {$gte: $Y$m$D, $lte: $NOW}}
	>> and关系
		{$and: [{id: xxx, age: xxx}]}
	>> 排序（倒序）
		.sort({time: -1})
		.order_by({time: -1})

> ss API 调用趋势
	>> 需求
		>>> 查询每天
			
				
> 需要重装为debian10 机器
	>> 192.192.100.72  192.192.100.73   192.192.100.78    192.192.100.37  80-82
	
> traceroute
	>> 概念
		traceroute 是Linux和Mac OS等系统默认提供的路由追踪小程序，能探测数据包从源地址到目的地址经过的路由器的IP地址
	>> 原理
		  1. 从源地址发出一个UDP探测包到目的地址，并将TTL设置为1；
			2. 到达路由器时，将TTL减1；
			3. 当TTL变为0时，包被丢弃，路由器向源地址发回一个ICMP超时通知（ICMP Time Exceeded Message），内含发送IP包的源地址，IP包的所有内容及路由器的IP地址；
			4. 当源地址收到该ICMP包时，显示这一跳路由信息；
			5. 重复1～5，并每次设置TTL加1；
			6. 直至目标地址收到探测数据包，并返回端口不可达通知（ICMP Port Unreachable）；
			7. 当源地址收到ICMP Port Unreachable包时停止traceroute。
	>> 常用选项
	>> e.g.
		>>> traceroute www.baidu.com

> 37 
> 69 演示
> 72 伟彪测试环境
> 73 
> 78
> 79 
