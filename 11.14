> 问题：想要实现将jumpserver-core项目通过海恩系统进行展示，但是登录时因为header里面是没有身份信息的，所以验证不通过。
	>> https://www.cnblogs.com/jying/p/13555016.html
	>> https://www.yisu.com/zixun/537241.html        改为https是可能成功的
> 方案：前端iframe 采用token放在url里面，后端的django在解析的时候针对这个这个域名，解析url。就是说：在原本只进行header解析的机制不变，再加一套url解析，将解析到的token等字段进行验权。
	>> 1. 加入一个middleware 设置request中cookie值。 问题： request貌似不可改变

todo
> csrf_token 数据传递机制
> django csrf的处理

> reverse 反向路由解析
	>> https://www.dusaiphoto.com/article/79/
	>> path('/foo', ..., name=foo_name) 只需要reverse("/foo")就可以得到foo_name 这个路径别名，这样做的目的是防止硬编码

> django Signal机制: https://www.liujiangblog.com/course/django/170

> 解决方案：
	>> 方案一： enable cookie问题： apps/authentication/views/login/UserLoginView/form_valid() 注释81L 82L 也就是不进行session的验证
		>>> session
	>> 重定向到login_guard
		>>> auth_login
			>>>> common/utils/django/get_object_or_none 获取user  user.backend被赋值
		>>> send_auth_signal 需要保留，因为保留了日志等信息
		>>> clear_auth_mark  需要保留，清除了META header的信息
		>>> redirect_user_first_login_or_index 这个取得了真正的登录url，如果之前没有登录信息，会跳到index页面

	>> 方案二：token转化为cookie等信息进行验证（利用authmiddleware中间件进行token->cookie的转化，从而实现了持久化身份验证（不需要每次request进行验权））
		>>> form_valid 中 
		>>> get_private_token
		>>> AuthenticationMiddleware 实现了对 request.user的赋值 if not request.user then (get_request_from_session and set_request_user)
		>>> 实施
		  >>>> 获取private_token 通过python
			>>>> 在Cookie设置sessionid 即可
	>> 方案三：设置Set-Cookie 为 SameSite=None; Secure    settings文件添加字段SESSION_COOKIE_SECURE=true ，但是需要设置为https
		>>> https://www.cnblogs.com/jying/p/13555016.html
	>> 方案四：自定义中间件，因为sessionid是固定的，所以可以将admin用户的sessionid放入到cookie中，这样，可以直接获取到session了

django
> request.META
	>> request.MATE获取的是一个标准的python字典。它包含了所有的HTTP请求信息
> request.COOKIES
	>> 是一个字典，里面可能保存了sessionid和csrf（默认是这样）可以直接赋值
> request.user 机制
	>> request.user 是通过session进行获取的（在authenticationMiddleware中做了一个逻辑，if not request.user then (get_request_from_session and set_request_user)）
> request.session
	>> 使用了session app和sessionmiddleware后通过cookie获取sessionid，然后通过sessionstore(sessionid) 获取到用户的session赋值给request.session
> request.method
	>> 通过request.method 获取到请求类型 get返回 'GET'
> request.GET.get('token')
	>> 获取路径传参中token的值 /?token=111
> request.POST
	>> 同上

django 中间件
> SessionMiddleware 机制
	>> https://www.jianshu.com/p/daa1f1cc6944 SessionMiddleware 源码学习
	>> 请求过来时将cookie中的信息加载
	>> 应答时 set_cookie
> AuthenticationMiddleware 实现了对 request.user的赋值 if not request.user then (get_request_from_session and set_request_user)


> authentication

> 目的：获取admin的sessionid，他应该为其中一个键
> 问题：session保存到了redis，如何获取 django_redis get_redis_connection 读取 django.core.cache.cache 设置
	>> 值直接保存redis第一层 KEYS * 获取。思路：通过遍历解码判断进行admin sessionid
	>> 先base64解码，split(:)[-1],  pickle.loads(HIGHEST_PROTOCOL) 到底是 sessionserializer 还是 jsonserializer 还是pickleserializer